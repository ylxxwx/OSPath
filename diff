diff --git a/30-mprocess/README.md b/30-mprocess/README.md
index 5af00b2..7da1a6c 100644
--- a/30-mprocess/README.md
+++ b/30-mprocess/README.md
@@ -8,7 +8,7 @@
     to do list
      1) sys_fork                   done.
      2) copy page table            done.
-     3) new thread?                
+     3) new thread?                done. 
      3) switch context             done.
      4) copy on write              done.
      5) sys_exec                   
diff --git a/30-mprocess/apps/Makefile b/30-mprocess/apps/Makefile
index f82f0b4..9fad19f 100644
--- a/30-mprocess/apps/Makefile
+++ b/30-mprocess/apps/Makefile
@@ -4,13 +4,13 @@
 CC = gcc
 GDB = gdb
 CFLAGS = -g -fno-pie -m32 -ffreestanding 
-LDFLAGS = -m elf_i386  -T./link.ld
+LDFLAGS = -m elf_i386 -T./link.ld -z noexecstack
 
 C_SOURCES = $(wildcard common/*.c *.c)
 HEADERS = $(wildcard common/*.h)
 INC = common
 # Nice syntax for file extension replacement
-OBJS = ${C_SOURCES:.c=.o common/entry.o}
+OBJS = ${C_SOURCES:.c=.o }
 
 all: shell
 
diff --git a/30-mprocess/apps/common/entry.asm b/30-mprocess/apps/common/entry.asm
index 2021730..28d7a0d 100644
--- a/30-mprocess/apps/common/entry.asm
+++ b/30-mprocess/apps/common/entry.asm
@@ -1,4 +1,6 @@
 [global start]
 [extern __start__]
+
 start:
+_start:
 call __start__
\ No newline at end of file
diff --git a/30-mprocess/apps/common/entry.o b/30-mprocess/apps/common/entry.o
index 7a4c9e2..15c70ed 100644
Binary files a/30-mprocess/apps/common/entry.o and b/30-mprocess/apps/common/entry.o differ
diff --git a/30-mprocess/apps/common/io.c b/30-mprocess/apps/common/io.c
index 09f006a..6b47d10 100644
--- a/30-mprocess/apps/common/io.c
+++ b/30-mprocess/apps/common/io.c
@@ -3,20 +3,17 @@
 #include "utils.h"
 #include "syscall_user.h"
 
-s32 input(u8 * buf) {
-    return sys_std_input(buf);
+s32 input(u8 *buf)
+{
+  return sys_input(buf);
 }
 
-s32 output(char *fmt,...) {
+s32 output(char *fmt, ...)
+{
   void *ebp = 0;
-  __asm__ __volatile__ (
+  __asm__ __volatile__(
       "mov %%ebp, %0;"
-      :"=m"(ebp)
-  );
+      : "=m"(ebp));
   void *arg_ptr = (void *)(ebp + 12);
   return sys_print(fmt, arg_ptr);
 }
-
-s32 std_clear_screen() {
-  return sys_clear_screen();
-}
\ No newline at end of file
diff --git a/30-mprocess/apps/common/io.h b/30-mprocess/apps/common/io.h
index ba0e54f..dbc716b 100644
--- a/30-mprocess/apps/common/io.h
+++ b/30-mprocess/apps/common/io.h
@@ -3,8 +3,7 @@
 
 #include "type.h"
 
-s32 input(u8 * buf);
-s32 output(char *fmt,...);
-s32 std_clear_screen();
+s32 input(u8 *buf);
+s32 output(char *fmt, ...);
 
 #endif
diff --git a/30-mprocess/apps/common/io.o b/30-mprocess/apps/common/io.o
index 405ac5b..e84b6a3 100644
Binary files a/30-mprocess/apps/common/io.o and b/30-mprocess/apps/common/io.o differ
diff --git a/30-mprocess/apps/common/syscall_user.c b/30-mprocess/apps/common/syscall_user.c
index 849c44d..472ce62 100644
--- a/30-mprocess/apps/common/syscall_user.c
+++ b/30-mprocess/apps/common/syscall_user.c
@@ -1,78 +1,52 @@
 #include "syscall_user.h"
 
-s32 sys_sleep() {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "movl $0, %%eax;"
-        "int $0x80;"
-        "mov %%eax, %0"
-        : "=m"(ret)
-        :);
-    return ret;
-}
+#define SYS_SLEEP 0x00
+#define SYS_INPUT 0x04
+#define SYS_CLS 0x05
+#define SYS_LS 0x06
+#define SYS_PWD 0x09
+#define SYS_EXIT 0x0A
+#define SYS_FORK 0x0C
 
-s32 sys_mount_root(u32 major, u32 min, u32 partition) {
+s32 sys_general(u32 sys_id, u32 param1, u32 param2)
+{
     s32 ret = 0;
     __asm__ __volatile__(
         "push %%ebx;"
-        "movl $2, %%eax;"
         "int $0x80;"
         "pop %%ebx;"
         "mov %%eax, %0;"
         : "=m"(ret)
-        : "b"(major),"c"(min),"d"(partition));
+        : "a"(sys_id), "b"(param1), "c"(param2));
     return ret;
 }
 
-s32 sys_print(char* fmt, void *arg) {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "push %%ebx;"
-        "movl $3, %%eax;"
-        "int $0x80;"
-        "pop %%ebx;"
-        "mov %%eax, %0;"
-        : "=m"(ret)
-        : "b"(fmt),"c"(arg));
-    return ret;
-}
-
-s32 sys_std_input(char *buf) {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "push %%ebx;"
-        "movl $4, %%eax;"
-        "int $0x80;"
-        "pop %%ebx;"
-        "mov %%eax, %0;"
-        : "=m"(ret)
-        : "b"(buf));
-    return ret;
-}
-
-s32 sys_clear_screen() {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "movl $5, %%eax;"
-        "int $0x80;"
-        "mov %%eax, %0;"
-        : "=m"(ret)
-        :);
-    return ret;
-}
+#define SYS_PARAM_ZERO(func_name, sys_id) \
+    s32 func_name()                       \
+    {                                     \
+        return sys_general(sys_id, 0, 0); \
+    }
+#define SYS_PARAM_ONE(func_name, sys_id)      \
+    s32 func_name(u32 param)                  \
+    {                                         \
+        return sys_general(sys_id, param, 0); \
+    }
+#define SYS_PARAM_TWO(func_name, sys_id)            \
+    s32 func_name(u32 param1, u32 param2)           \
+    {                                               \
+        return sys_general(sys_id, param1, param2); \
+    }
 
-s32 sys_ls(char *dir) {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "movl $6, %%eax;"
-        "int $0x80;"
-        "mov %%eax, %0;"
-        : "=m"(ret)
-        : "b"(dir));
-    return ret;
-}
+SYS_PARAM_ZERO(sys_sleep, SYS_SLEEP)
+SYS_PARAM_ZERO(sys_cls, SYS_CLS)
+SYS_PARAM_ZERO(sys_pwd, SYS_PWD)
+SYS_PARAM_ZERO(sys_exit, SYS_EXIT)
+SYS_PARAM_ZERO(sys_fork, SYS_FORK)
+SYS_PARAM_ONE(sys_input, SYS_INPUT)
+SYS_PARAM_ONE(sys_ls, SYS_LS)
 
-s32 sys_cd_dir(char *dir) {
+s32 sys_cd_dir(char *dir)
+{
     s32 ret = 0;
     __asm__ __volatile__(
         "push %%ebx;"
@@ -85,62 +59,44 @@ s32 sys_cd_dir(char *dir) {
     return ret;
 }
 
-s32 sys_read_file(char *fn, char *buf) {
+s32 sys_mount_root(u32 major, u32 min, u32 partition)
+{
     s32 ret = 0;
     __asm__ __volatile__(
         "push %%ebx;"
-        "movl $8, %%eax;"
+        "movl $2, %%eax;"
         "int $0x80;"
         "pop %%ebx;"
         "mov %%eax, %0;"
         : "=m"(ret)
-        : "b"(fn),"c"(buf));
+        : "b"(major), "c"(min), "d"(partition));
     return ret;
 }
 
-s32 sys_pwd() {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "movl $9, %%eax;"
-        "int $0x80;"
-        "mov %%eax, %0;"
-        : "=m"(ret)
-        :);
-    return ret;
-}
-
-s32 sys_printval(u32 val) {
+s32 sys_print(char *fmt, void *arg)
+{
     s32 ret = 0;
     __asm__ __volatile__(
         "push %%ebx;"
-        "movl $0xA, %%eax;"
+        "movl $3, %%eax;"
         "int $0x80;"
         "pop %%ebx;"
         "mov %%eax, %0;"
         : "=m"(ret)
-        : "b"(val));
+        : "b"(fmt), "c"(arg));
     return ret;
 }
 
-s32 sys_printstr(char *val) {
+s32 sys_read_file(char *fn, char *buf)
+{
     s32 ret = 0;
     __asm__ __volatile__(
         "push %%ebx;"
-        "movl $0xB, %%eax;"
+        "movl $8, %%eax;"
         "int $0x80;"
         "pop %%ebx;"
         "mov %%eax, %0;"
         : "=m"(ret)
-        : "b"(val));
-    return ret;
-}
-
-s32 sys_fork() {
-    s32 ret = 0;
-    __asm__ __volatile__(
-        "movl $0xC, %%eax;"
-        "int $0x80;"
-        "mov %%eax, %0;"
-        : "=m"(ret));
+        : "b"(fn), "c"(buf));
     return ret;
 }
diff --git a/30-mprocess/apps/common/syscall_user.h b/30-mprocess/apps/common/syscall_user.h
index d213ceb..b6ee492 100644
--- a/30-mprocess/apps/common/syscall_user.h
+++ b/30-mprocess/apps/common/syscall_user.h
@@ -4,14 +4,16 @@
 #include "type.h"
 
 s32 sys_fork();
-s32 sys_exec(char* path, u32 argc, char* argv[]);
 s32 sys_sleep();
-s32 sys_mount_root(u32 major, u32 min, u32 partition);
-s32 sys_print(char* fmt, void *arg);
-s32 sys_std_input(char *buf);
-s32 sys_clear_screen();
-s32 sys_ls(char *dir);
+s32 sys_pwd();
+s32 sys_cls();
+s32 sys_input(u32 buf_addr /*char *buf*/);
+s32 sys_ls(u32 dir_addr /* char **/);
 s32 sys_cd_dir(char *dir);
+s32 sys_print(char *fmt, void *arg);
 s32 sys_read_file(char *fn, char *buf);
-s32 sys_pwd();
+s32 sys_exec(char *path, u32 argc, char *argv[]);
+s32 sys_mount_root(u32 major, u32 min, u32 partition);
+s32 sys_exit();
+
 #endif // _SYSCALL_USER_H_
diff --git a/30-mprocess/apps/common/syscall_user.o b/30-mprocess/apps/common/syscall_user.o
index bc3b636..ec514e1 100644
Binary files a/30-mprocess/apps/common/syscall_user.o and b/30-mprocess/apps/common/syscall_user.o differ
diff --git a/30-mprocess/apps/link.ld b/30-mprocess/apps/link.ld
index 1d0def8..232853b 100644
--- a/30-mprocess/apps/link.ld
+++ b/30-mprocess/apps/link.ld
@@ -1,4 +1,6 @@
 ENTRY(start)
+OUTPUT_FORMAT(elf32-i386)
+
 SECTIONS
 {
   .text 0xA0000000:
@@ -13,14 +15,14 @@ SECTIONS
      data = .; _data = .; __data = .;
      *(.data)
      *(.rodata)
-     . = ALIGN(4096);
+     . = ALIGN(1024);
   }
 
   .bss :
   {
     bss = .; _bss = .; __bss = .;
     *(.bss)
-    . = ALIGN(4096);
+    . = ALIGN(1024);
   }
 
   end = .; _end = .; __end = .;
diff --git a/30-mprocess/apps/shell b/30-mprocess/apps/shell
index 45553f1..2a3668e 100755
Binary files a/30-mprocess/apps/shell and b/30-mprocess/apps/shell differ
diff --git a/30-mprocess/apps/shell.c b/30-mprocess/apps/shell.c
index ac97afb..181c37f 100644
--- a/30-mprocess/apps/shell.c
+++ b/30-mprocess/apps/shell.c
@@ -136,7 +136,7 @@ void execCmd(int cmd, int argc, char argv[][80])
     switch (cmd)
     {
     case CMD_CLS:
-        std_clear_screen();
+        sys_cls();
         break;
     case CMD_LS:
         if (argc == 1)
@@ -197,11 +197,12 @@ void execCmd(int cmd, int argc, char argv[][80])
     }
     case CMD_FORK:
     {
-        output("call sys_fork.\n");
         int ret = sys_fork();
         output("out of fork: ret:%d\n", ret);
         if (ret = 0)
         {
+            //  output("This is child thread.exit..\n");
+            //  sys_exit();
             while (1)
                 sys_sleep();
         }
diff --git a/30-mprocess/apps/shell.elf b/30-mprocess/apps/shell.elf
index 6a24c43..c61b0c5 100755
Binary files a/30-mprocess/apps/shell.elf and b/30-mprocess/apps/shell.elf differ
diff --git a/30-mprocess/apps/shell.o b/30-mprocess/apps/shell.o
index 2699ab6..fe9878e 100644
Binary files a/30-mprocess/apps/shell.o and b/30-mprocess/apps/shell.o differ
diff --git a/30-mprocess/cpu/isr.c b/30-mprocess/cpu/isr.c
index fa2acc5..242932b 100644
--- a/30-mprocess/cpu/isr.c
+++ b/30-mprocess/cpu/isr.c
@@ -127,7 +127,10 @@ void isr_handler(registers_t *r)
     // if (r->int_no < 32)
     //    kprintf("\nGot interrupt: %d, %s, %x\n",r->int_no, exception_messages[r->int_no], r->err_code);
     if (r->int_no == 0 || r->int_no == 6 || r->int_no == 13)
+    {
+        kprintf("\nGot interrupt: %d, %s, %x\n", r->int_no, exception_messages[r->int_no], r->err_code);
         panic("non recoverable.()");
+    }
 
     if (interrupt_handlers[r->int_no] != 0)
     {
diff --git a/30-mprocess/cpu/isr.h b/30-mprocess/cpu/isr.h
index 8dacd66..604ec35 100644
--- a/30-mprocess/cpu/isr.h
+++ b/30-mprocess/cpu/isr.h
@@ -73,7 +73,8 @@ extern void irs_sys();
 #define IRQ15 47
 
 /* Struct which aggregates many registers */
-typedef struct registers{
+typedef struct registers
+{
    u32 ds;                                     /* Data segment selector */
    u32 edi, esi, ebp, esp, ebx, edx, ecx, eax; /* Pushed by pusha. */
    u32 int_no, err_code;                       /* Interrupt number and error code (if applicable) */
@@ -86,7 +87,7 @@ void isr_install();
 void isr_handler(registers_t *r);
 void irq_install();
 
-typedef void (*isr_t)(registers_t*);
+typedef void (*isr_t)(registers_t *);
 void register_interrupt_handler(u8 n, isr_t handler);
 
 #endif
diff --git a/30-mprocess/libc/string.c b/30-mprocess/libc/string.c
index 491346f..e370150 100644
--- a/30-mprocess/libc/string.c
+++ b/30-mprocess/libc/string.c
@@ -2,86 +2,60 @@
 #include "../cpu/type.h"
 
 #define NULL 0
-/*void int_to_ascii(int n, char str[]) {
-    int i, sign;
-    if ((sign = n) < 0) n = -n;
-    i = 0;
-    do {
-        str[i++] = n % 10 + '0';
-    } while ((n /= 10) > 0);
-
-    if (sign < 0) str[i++] = '-';
-    str[i] = '\0';
-
-    reverse(str);
-}
-
-void hex_to_ascii(int n, char str[]) {
-    append(str, '0');
-    append(str, 'x');
-    char zeros = 0;
 
-    s32 tmp;
-    int i;
-    for (i = 28; i > 0; i -= 4) {
-        tmp = (n >> i) & 0xF;
-        if (tmp == 0 && zeros == 0) continue;
-        zeros = 1;
-        if (tmp > 0xA) append(str, tmp - 0xA + 'a');
-        else append(str, tmp + '0');
-    }
-
-    tmp = n & 0xF;
-    if (tmp >= 0xA) append(str, tmp - 0xA + 'a');
-    else append(str, tmp + '0');
-}
-*/
-/* K&R */
-void reverse(char s[]) {
+void reverse(char s[])
+{
     int c, i, j;
-    for (i = 0, j = strlen(s)-1; i < j; i++, j--) {
+    for (i = 0, j = strlen(s) - 1; i < j; i++, j--)
+    {
         c = s[i];
         s[i] = s[j];
         s[j] = c;
     }
 }
 
-/* K&R */
-int strlen(char s[]) {
+int strlen(char s[])
+{
     int i = 0;
-    while (s[i] != '\0') ++i;
+    while (s[i] != '\0')
+        ++i;
     return i;
 }
 
-void append(char s[], char n) {
+void append(char s[], char n)
+{
     int len = strlen(s);
     s[len] = n;
-    s[len+1] = '\0';
+    s[len + 1] = '\0';
 }
 
-int backspace(char s[]) {
+int backspace(char s[])
+{
     int len = strlen(s);
-    if (len > 0) {
-        s[len-1] = '\0';
+    if (len > 0)
+    {
+        s[len - 1] = '\0';
         return 0;
     }
     return -1;
 }
 
-/* K&R 
- * Returns <0 if s1<s2, 0 if s1==s2, >0 if s1>s2 */
-int strcmp(char s1[], char s2[]) {
+int strcmp(char s1[], char s2[])
+{
     int i;
-    for (i = 0; s1[i] == s2[i]; i++) {
-        if (s1[i] == '\0') return 0;
+    for (i = 0; s1[i] == s2[i]; i++)
+    {
+        if (s1[i] == '\0')
+            return 0;
     }
     return s1[i] - s2[i];
 }
 
-char* kstrcpy(char* destination, const char* source)
+char *kstrcpy(char *destination, const char *source)
 {
     // return if no memory is allocated to the destination
-    if (destination == NULL) {
+    if (destination == NULL)
+    {
         return NULL;
     }
 
@@ -107,10 +81,13 @@ char* kstrcpy(char* destination, const char* source)
 typedef u32 size_t;
 #define NULL 0
 
-size_t czf_strcspn(const char *s1, const char *s2) {
+size_t czf_strcspn(const char *s1, const char *s2)
+{
     const char *sc1, *sc2;
-    for (sc1 = s1; *sc1 != '\0'; ++sc1) {
-        for (sc2 = s2; *sc2 != '\0'; ++sc2) {
+    for (sc1 = s1; *sc1 != '\0'; ++sc1)
+    {
+        for (sc2 = s2; *sc2 != '\0'; ++sc2)
+        {
             if (*sc1 == *sc2)
                 return (sc1 - s1);
         }
@@ -119,13 +96,19 @@ size_t czf_strcspn(const char *s1, const char *s2) {
 }
 
 /* find index of first s1[i] that matches no s2[]. */
-size_t czf_strspn(const char *s1, const char *s2) {
+size_t czf_strspn(const char *s1, const char *s2)
+{
     const char *sc1, *sc2;
-    for (sc1 = s1; *sc1 != '\0'; ++sc1) {
-        for (sc2 = s2; ; ++sc2) {
-            if (*sc2 == '\0') {
+    for (sc1 = s1; *sc1 != '\0'; ++sc1)
+    {
+        for (sc2 = s2;; ++sc2)
+        {
+            if (*sc2 == '\0')
+            {
                 return (sc1 - s1);
-            } else if (*sc1 == *sc2) {
+            }
+            else if (*sc1 == *sc2)
+            {
                 break;
             }
         }
@@ -134,14 +117,16 @@ size_t czf_strspn(const char *s1, const char *s2) {
 }
 
 /* find next token in s1[] delimited by s2[]. */
-char *strtok(char *s1, const char *s2) {
+char *strtok(char *s1, const char *s2)
+{
     char *sbegin, *send;
     static char *ssave = "";
 
     sbegin = s1 ? s1 : ssave;
     sbegin += czf_strspn(sbegin, s2);
 
-    if (*sbegin == '\0') {
+    if (*sbegin == '\0')
+    {
         ssave = "";
         return NULL;
     }
@@ -154,12 +139,13 @@ char *strtok(char *s1, const char *s2) {
     return (sbegin);
 }
 
-int split(char dst[][80], char* str, char *spl)
+int split(char dst[][80], char *str, char *spl)
 {
     int n = 0;
     char *result = 0;
     result = strtok(str, spl);
-    while( result != 0 && *result != 0) {
+    while (result != 0 && *result != 0)
+    {
         kstrcpy(dst[n++], result);
         result = strtok(0, spl);
     }
diff --git a/30-mprocess/libc/string.h b/30-mprocess/libc/string.h
index 2388baa..5caae4c 100644
--- a/30-mprocess/libc/string.h
+++ b/30-mprocess/libc/string.h
@@ -10,7 +10,7 @@ int strlen(char s[]);
 int backspace(char s[]);
 void append(char s[], char n);
 int strcmp(char s1[], char s2[]);
-char * kstrcpy(char *dst, const char *src);
+char *kstrcpy(char *dst, const char *src);
 char *strtok(char *s1, const char *s2);
-int split(char dst[][80], char* str, char *spl);
+int split(char dst[][80], char *str, char *spl);
 #endif
diff --git a/30-mprocess/syscall/fork.c b/30-mprocess/syscall/fork.c
index 6bec5c4..432830f 100644
--- a/30-mprocess/syscall/fork.c
+++ b/30-mprocess/syscall/fork.c
@@ -1,23 +1,29 @@
 #include "syscall.h"
 #include "isr.h"
 #include "panic.h"
-#include "schedule.h"
 #include "screen.h"
 #include "process.h"
 #include "task.h"
 
+s32 ksys_exit(registers_t *regs)
+{
+    mov_cur_task_dead();
+}
+
 s32 ksys_fork(registers_t *regs)
 {
     kprintf("sys calll: fork:\n");
+
+    tcb_t *thread = fork_crt_thread();
+    if (thread == 0)
+        panic("clone thread failed.");
+
     // Create a new process, with page directory cloned from this process.
     pcb_t *process = create_process("new", /* is_kernel_process = */ false);
 
     pcb_t *parent_process = get_cur_thread()->process;
     process->parent = parent_process;
     // add_child_process(parent_process, process);
-    tcb_t *thread = fork_crt_thread();
-    if (thread == 0)
-        panic("clone thread failed.");
 
     thread->process = process;
 
diff --git a/30-mprocess/syscall/syscall.c b/30-mprocess/syscall/syscall.c
index 903e8c8..fd73759 100644
--- a/30-mprocess/syscall/syscall.c
+++ b/30-mprocess/syscall/syscall.c
@@ -6,62 +6,12 @@
 #include "keyboard.h"
 #include "vfs.h"
 
-extern int cur_task_id;
-extern s32 ksys_fork(registers_t *regs);
-
-typedef s32 (*sys_func)(registers_t *regs);
-
-static s32 syscall_handler(registers_t *regs);
-
-s32 ksys_printstr(registers_t *regs)
-{
-    u32 val = (u32)regs->ebx;
-    kprintf("Val:%s\n", val);
-    return 0;
-}
-
-s32 ksys_printhex(registers_t *regs)
+s32 ksys_nil(registers_t *regs)
 {
-    u32 val = (u32)regs->ebx;
-    kprintf("Val:%x\n", val);
+    kprintf("sys call nil serice.\n");
     return 0;
 }
 
-s32 ksys_pwd(registers_t *regs)
-{
-    vfs_pwd();
-    return 9;
-}
-
-s32 ksys_read_file(registers_t *regs)
-{
-    char *fn = (char *)regs->ebx;
-    void *buf = (void *)regs->ecx;
-    int sz = vfs_read_file(fn, buf);
-    return sz;
-}
-
-s32 ksys_cd_dir(registers_t *regs)
-{
-    u8 *dir = (u8 *)regs->ebx;
-    cd_dir(dir);
-    return 7;
-}
-
-s32 sys_kstd_input(registers_t *regs)
-{
-    u8 *buf = (u8 *)regs->ebx;
-    return kb_read(buf);
-}
-
-s32 sys_kprint(registers_t *regs)
-{
-    char *fmt = (char *)regs->ebx;
-    void *args = (void *)regs->ecx;
-    kprintf_args(fmt, args);
-    return 3;
-}
-
 s32 ksys_sleep(registers_t *regs)
 {
     kprintf("sys call sleep...\n");
@@ -69,58 +19,34 @@ s32 ksys_sleep(registers_t *regs)
     return 2;
 }
 
-s32 sys_kstd_clear_screen(registers_t *regs)
+s32 ksys_cls(registers_t *regs)
 {
     clear_screen();
     return 3;
 }
 
-s32 mount_hd(registers_t *regs)
-{
-    kprintf("sys mount maj:%d, min:%d, part:%d\n", regs->ebx, regs->ecx, regs->edx);
-
-    disk_t t;
-    t.major = 1;
-    t.minor = 0;
-    t.partition = 0;
-    mount_root(&t);
-    return 9;
-}
-
-s32 ksys_ls(registers_t *regs)
-{
-    char *dir = (char *)(regs->ebx);
-    ls_dir(dir);
-    return 10;
-}
-
-static void *syscalls[] =
-    {
+static void *syscalls[] = {
     &ksys_sleep,
     &ksys_sleep,
-        &mount_hd,
-        &sys_kprint,
-        &sys_kstd_input,
-        &sys_kstd_clear_screen,
+    &ksys_mount,
+    &ksys_print,
+    &ksys_input,
+    &ksys_cls,
     &ksys_ls,
     &ksys_cd_dir,
     &ksys_read_file,
     &ksys_pwd,
-        &ksys_printhex,
-        &ksys_printstr,
+    &ksys_exit,
+    &ksys_nil,
     &ksys_fork,
 };
 
-u32 num_syscalls = 3;
-
 s32 sys_handler(registers_t *r)
 {
-    // kprintf("system call 128:%d\n", r->err_code);
     if (r->err_code < sizeof(syscalls))
     {
         sys_func func = syscalls[r->err_code];
         s32 ret = func(r);
-        // kprintf("sys handle return :%d\n", ret);
         return ret;
     }
     else
@@ -132,6 +58,4 @@ s32 sys_handler(registers_t *r)
 
 void init_syscalls()
 {
-    // Register our syscall handler.
-    // register_interrupt_handler (0x80, &sys_handler);
 }
diff --git a/30-mprocess/syscall/syscall.h b/30-mprocess/syscall/syscall.h
index a4646cc..b44c5c9 100644
--- a/30-mprocess/syscall/syscall.h
+++ b/30-mprocess/syscall/syscall.h
@@ -1,6 +1,20 @@
 #ifndef SYSCALL_H
 #define SYSCALL_H
 
+#include "type.h"
+#include "isr.h"
+
+typedef s32 (*sys_func)(registers_t *regs);
+
+s32 ksys_pwd(registers_t *regs);
+s32 ksys_read_file(registers_t *regs);
+s32 ksys_cd_dir(registers_t *regs);
+s32 ksys_ls(registers_t *regs);
+s32 ksys_mount(registers_t *regs);
+s32 ksys_input(registers_t *regs);
+s32 ksys_print(registers_t *regs);
+s32 ksys_fork(registers_t *regs);
+s32 ksys_exit(registers_t *regs);
 void init_syscalls();
 
 #endif
\ No newline at end of file
diff --git a/30-mprocess/syscall/syscall_file.c b/30-mprocess/syscall/syscall_file.c
new file mode 100644
index 0000000..69de1ca
--- /dev/null
+++ b/30-mprocess/syscall/syscall_file.c
@@ -0,0 +1,59 @@
+#include "syscall.h"
+#include "isr.h"
+#include "screen.h"
+#include "keyboard.h"
+#include "vfs.h"
+
+s32 ksys_pwd(registers_t *regs)
+{
+    vfs_pwd();
+    return 9;
+}
+
+s32 ksys_read_file(registers_t *regs)
+{
+    char *fn = (char *)regs->ebx;
+    void *buf = (void *)regs->ecx;
+    int sz = vfs_read_file(fn, buf);
+    return sz;
+}
+
+s32 ksys_cd_dir(registers_t *regs)
+{
+    u8 *dir = (u8 *)regs->ebx;
+    cd_dir(dir);
+    return 7;
+}
+
+s32 ksys_input(registers_t *regs)
+{
+    u8 *buf = (u8 *)regs->ebx;
+    return kb_read(buf);
+}
+
+s32 ksys_print(registers_t *regs)
+{
+    char *fmt = (char *)regs->ebx;
+    void *args = (void *)regs->ecx;
+    kprintf_args(fmt, args);
+    return 3;
+}
+
+s32 ksys_mount(registers_t *regs)
+{
+    kprintf("sys mount maj:%d, min:%d, part:%d\n", regs->ebx, regs->ecx, regs->edx);
+
+    disk_t t;
+    t.major = 1;
+    t.minor = 0;
+    t.partition = 0;
+    mount_root(&t);
+    return 9;
+}
+
+s32 ksys_ls(registers_t *regs)
+{
+    char *dir = (char *)(regs->ebx);
+    ls_dir(dir);
+    return 10;
+}
diff --git a/30-mprocess/task/process.c b/30-mprocess/task/process.c
index d7de882..f97ff4e 100644
--- a/30-mprocess/task/process.c
+++ b/30-mprocess/task/process.c
@@ -5,28 +5,33 @@
 static pcb_t *processes[4];
 static int cur_process = 0;
 
-int find_avail_id() {
-    for(int idx = 0; idx < 4; idx++) {
+int find_avail_id()
+{
+    for (int idx = 0; idx < 4; idx++)
+    {
         if (processes[idx] == 0)
             return idx;
     }
     return -1;
 }
 
-pcb_t *create_process(char *name, int is_kernel_process) {
-  pcb_t* process = (pcb_t*)kmalloc(sizeof(pcb_t));
+pcb_t *create_process(char *name, int is_kernel_process)
+{
+    pcb_t *process = (pcb_t *)kmalloc(sizeof(pcb_t));
     kmemset(process, 0, sizeof(pcb_t));
 
     uint32 id = find_avail_id();
     if (id == -1)
         panic("no more process resource.");
     process->id = id;
-  //if (name != NULL) {
-  //  kstrcpy(process->name, name);
-  //} else {
-    //char buf[16];
-    //sprintf(buf, "process-%u", process->id);
-    //kstrcpy(process->name, buf);
+    if (name != NULL)
+    {
+        kstrcpy(process->name, name);
+    }
+    // else {
+    // char buf[16];
+    // sprintf(buf, "process-%u", process->id);
+    // kstrcpy(process->name, buf);
     //}
     process->parent = NULL;
 
@@ -34,6 +39,6 @@ pcb_t *create_process(char *name, int is_kernel_process) {
     process->is_kernel_process = is_kernel_process;
     process->exit_code = 0;
     process->page_dir = clone_crt_page_dir(current_directory);
-  //kprintf("process dir:va:%x pa:%x\n", process->page_dir->tablesPhysical, vaddr_to_paddr(process->page_dir->tablesPhysical));
+    // kprintf("process dir:va:%x pa:%x\n", process->page_dir->tablesPhysical, vaddr_to_paddr(process->page_dir->tablesPhysical));
     return process;
 }
diff --git a/30-mprocess/task/process.h b/30-mprocess/task/process.h
index 3b583c0..95348ab 100644
--- a/30-mprocess/task/process.h
+++ b/30-mprocess/task/process.h
@@ -3,18 +3,21 @@
 
 #include "type.h"
 #include "page.h"
-
-typedef enum {
+// #include "task.h"
+typedef enum
+{
     PROCESS_NORMAL,
     PROCESS_EXIT,
     PROCESS_EXIT_ZOMBIE
 } process_status;
 
-typedef struct pcb{
+typedef struct pcb
+{
     int id;
     char name[16];
     int thread_id[4];
     struct pcb *parent;
+    // tcb_t *threads[4];
     process_status status;
     // exit code
     int32 exit_code;
diff --git a/30-mprocess/task/task.c b/30-mprocess/task/task.c
index 1f752a6..91184ad 100644
--- a/30-mprocess/task/task.c
+++ b/30-mprocess/task/task.c
@@ -26,6 +26,7 @@ tcb_t *fork_crt_thread()
   tcb_t *thread = &tcb[id];
   if (thread == 0)
   {
+    panic("for_crt_thread no thread available.");
     return 0;
   }
   kmemcpy((void *)thread, (void *)get_cur_thread(), sizeof(struct task_struct));
@@ -41,16 +42,14 @@ tcb_t *fork_crt_thread()
   // allocate kernel stack
   uint32 kernel_stack = (uint32)kmalloc_a(KERNEL_STACK_SIZE, 1);
   thread->kernel_stack = kernel_stack;
-  kmemcpy((void *)kernel_stack, (void *)cur_thread->kernel_stack, KERNEL_STACK_SIZE);
+  kmemcpy((u8 *)kernel_stack, (u8 *)cur_thread->kernel_stack, KERNEL_STACK_SIZE);
 
   thread->kernel_esp =
       kernel_stack + KERNEL_STACK_SIZE - (sizeof(interrupt_stack_t) + sizeof(switch_stack_t));
-  // monitor_printf("fork kernel_esp = %x\n", thread->kernel_esp);
 
   interrupt_stack_t *interrupt_stack =
       (interrupt_stack_t *)(thread->kernel_esp + sizeof(switch_stack_t));
-  // monitor_printf("user eip = %x\n", interrupt_stack->eip);
-
+  kprintf("new thread interrupt_stack:%x\n", interrupt_stack);
   switch_stack_t *switch_stack = (switch_stack_t *)thread->kernel_esp;
   switch_stack->thread_entry_eip = (uint32)syscall_fork_exit;
 
@@ -62,6 +61,11 @@ tcb_t *get_cur_thread()
   return &tcb[cur_task_id];
 }
 
+void mov_cur_task_dead()
+{
+  tcb[cur_task_id].status = TASK_DEAD;
+}
+
 void mov_task_ready(int task_id)
 {
   tcb[task_id].status = TASK_READY;
diff --git a/30-mprocess/task/task.h b/30-mprocess/task/task.h
index bdddf08..a08e240 100644
--- a/30-mprocess/task/task.h
+++ b/30-mprocess/task/task.h
@@ -79,6 +79,7 @@ void init_task();
 
 void mov_task_ready(int task_id);
 void mov_task_wait(int task_id);
+void mov_cur_task_dead();
 
 // Create a new thread.
 tcb_t *create_thread(pcb_t *, char *name, thread_func function, uint32 priority, uint8 user);
diff --git a/30-mprocess/task/task_switch.asm b/30-mprocess/task/task_switch.asm
index dc4b4e6..5c93e69 100644
--- a/30-mprocess/task/task_switch.asm
+++ b/30-mprocess/task/task_switch.asm
@@ -3,6 +3,7 @@
 [global switch_to_user_mode]
 [global syscall_fork_exit]
 [extern interrupt_exit]
+[extern kprint_hex]
 
 context_switch:
   push eax
@@ -39,6 +40,10 @@ syscall_fork_exit:
   ; move esp to interrupt stack
   add esp, 8
 
+  ;push esp
+  ;call kprint_hex
+  ;pop esp
+
   ; recover the original data segment.
   pop ecx
   mov ds, cx
@@ -53,11 +58,23 @@ syscall_fork_exit:
   pop ebx
   pop edx
   pop ecx
+
   mov eax, 0  ; child process returns 0
   add esp, 4
 
   ; pop dummy values
   add esp, 8
   
+  sti
   ; pop eip, cs, eflags, user_esp and user_ss by processor
   iret
+
+
+  popa
+  ; clean up the pushed error code and pushed ISR number
+  add esp, 8
+
+  ; make sure interrupt is enabled
+  sti
+  ; pop cs, eip, eflags, user_ss, and user_esp by processor
+  iret
diff --git a/README.md b/README.md
index 256e877..d1a151d 100644
--- a/README.md
+++ b/README.md
@@ -10,3 +10,5 @@ All my study is based on the two projects above.
 cfenollosa/os-tutorial is a very good study material for OS learning. It builds the OS step by step so we can easily learn the OS piece by piece.
 The reason I want to clone from cfenollosa and change it is to run it in my Ubuntu environement.
 And I added support for GRUB and run/debug it with bochs.
+
+http://www.osdever.net/bkerndev/Docs/whatsleft.htm
diff --git a/mkfile/buildiso/iso/boot/kernel.elf b/mkfile/buildiso/iso/boot/kernel.elf
index 537904b..1259e93 100755
Binary files a/mkfile/buildiso/iso/boot/kernel.elf and b/mkfile/buildiso/iso/boot/kernel.elf differ
diff --git a/mkfile/buildiso/os.iso b/mkfile/buildiso/os.iso
index a470051..129445e 100644
Binary files a/mkfile/buildiso/os.iso and b/mkfile/buildiso/os.iso differ
diff --git a/mkfile/hda.img b/mkfile/hda.img
index 5654c9b..bc0a0f3 100644
Binary files a/mkfile/hda.img and b/mkfile/hda.img differ
diff --git a/mkfile/isoMakefile b/mkfile/isoMakefile
index 19a6fc3..c4299de 100644
--- a/mkfile/isoMakefile
+++ b/mkfile/isoMakefile
@@ -1,7 +1,7 @@
 ISOBUILDDIR=../mkfile/buildiso
 
 iso: os.iso
-	qemu-system-x86_64 -boot d -cdrom os.iso -drive format=raw,id=disk,file=../mkfile/hda.img
+	qemu-system-x86_64 -m 64m -boot d -cdrom os.iso -drive format=raw,id=disk,file=../mkfile/hda.img
 dbgiso: os.iso
 	bochsdbg -f ../mkfile/bochsenv/bochsiso.bochsrc
 os.iso: kernel.elf
